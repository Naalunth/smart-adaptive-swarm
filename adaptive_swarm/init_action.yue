with aura_env
    .AURA_SWARM_HEAL = 391891
    .AURA_SWARM_DAMAGE = 391889
    .AURA_FLOURISH = 197721
    .SPELL_SWARM = 391888
    .SPELL_GCD = 61304

    .CONFIG_SOUND_NEVER = 1
    .CONFIG_SOUND_FOCUS = 2
    .CONFIG_SOUND_ALL = 3
    
    .SOUND_NONE = 0
    .SOUND_COOLDOWN = 1
    .SOUND_FOCUS = 2

    .swarms = {}
    .nextUpdate = 0
    .lastExp = GetTime!
    .focusTarget = if .config.focusTarget then "target" else "focus"

    .lowestHealth = ->
        lowest = unit: "", ratio: 999999999
        maximum = unit: "", max: 0

        for unit in WA_IterateGroupMembers!
            if UnitIsDead unit then continue
            health = UnitHealth unit
            max = UnitHealthMax unit
            ratio = if max > 0 then health / max else 1
            hasSwarm = false
            for swarm in *.swarms
                if swarm.unit == unit then
                    hasSwarm = true
                    break
            if not hasSwarm
                lowest = {:unit, :ratio} if ratio < lowest.ratio
                maximum = {:unit, :max} if max > maximum.max

        if lowest.ratio <= 0.95 then lowest.unit
        else maximum.unit
    
    .lowestDuration = ->
        lowest = 20
        for swarm in *.swarms
            if swarm.count > 1
                lowest = min(swarm.expirationTime - GetTime!, lowest)
        lowest
    
    -- maps from stack count to importance
    .priority = (count) -> 
        ({
            [2]: 2
            [1]: 1
            [3]: 0
        })[count]
    
    -- find the best ally to cast swarm on
    -- returns the unitId or nil
    .optimalAlly = -> 
        bestAura = nil
        for swarm in *.swarms
            _, distance = WeakAuras.GetRange swarm.unit
            unless distance? then continue
            travelTime = .travelTime distance
            durationLeft = swarm.expirationTime - GetTime!

            -- skip if the buff can't be reapplied in time
            if travelTime + .config.delay > durationLeft then continue

            -- otherwise search for the best target
            auraPriority = .priority swarm.count
            bestPriority = .priority bestAura.count
            if auraPriority? and (not bestAura? \
                or auraPriority > bestPriority \
                or auraPriority == bestPriority and swarm.expirationTime > bestAura.expirationTime \
            )
                bestAura = aura
        return bestAura?.unit
    
    -- returns true if we should cast the next swarm on the focus target
    .shouldCastOnFocus = ->
        unless .config.focus and UnitExists(.focusTarget) and UnitCanAttack("player", .focusTarget)
            return false
        
        hasSwarm = false
        result = false
        do
            (aura) <- AuraUtil.ForEachAura .focusTarget, "HARMFUL", nil, _, true
            if aura.spellId != .AURA_SWARM_DAMAGE then return false
            hasSwarm = true

            distance, _ = WeakAuras.GetRange .focusTarget
            travelTime = .travelTime distance
            durationLeft = aura.expirationTime - GetTime!

            if travelTime + .config.delay > durationLeft \
                    or durationLeft < 4 + travelTime and (aura.count ?? 1) <= 2 \
                    or durationLeft < 6
                result = true
            
            true
        
        return result or not hasSwarm and .lowestDuration! > 6 and GetTime! - .lastExp > 2
    
    .travelTime = (distance) -> distance * 0.0833333 + 0.125